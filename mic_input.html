<!DOCTYPE html>
<html lang="ko">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>Web Audio API를 사용한 오디오 녹음</title>
  <style>
    body {
      font-family: system-ui, -apple-system, BlinkMacSystemFont, 'Segoe UI', sans-serif;
      padding: 24px;
      line-height: 1.5;
    }

    button {
      padding: 10px 18px;
      margin-right: 10px;
      border-radius: 6px;
      border: 1px solid #888;
      font-size: 16px;
      cursor: pointer;
    }

    button:disabled {
      opacity: 0.5;
      cursor: not-allowed;
    }

    #audioElement {
      display: block;
      margin-top: 20px;
      width: 100%;
    }

    #statusText {
      margin-top: 16px;
      color: #333;
    }

    #downloadLink {
      display: inline-block;
      margin-top: 12px;
    }

    #dirStatus {
      margin-top: 12px;
      font-size: 14px;
      color: #555;
    }

    .hidden {
      display: none !important;
    }
  </style>
</head>
<body>
  <button id="startButton">녹음 시작</button>
  <button id="stopButton" disabled>녹음 중지</button>
  <button id="dirButton" type="button">저장 폴더 선택</button>
  <audio id="audioElement" controls></audio>
  <p id="dirStatus">목표 폴더: C:\dev\SmartCloset (브라우저에서 직접 지정해 주세요)</p>
  <p id="statusText" aria-live="polite">대기 중</p>
  <a id="downloadLink" class="hidden" download="my_record.mp3">my_record.mp3 다운로드</a>

  <script src="https://cdn.jsdelivr.net/npm/lamejs@1.2.0/lame.min.js"></script>
<script>
let audioContext = null;
let processorNode = null;
let sourceNode = null;
let monitorNode = null;
let audioChunks = [];
let micStream = null;
let audioSampleRate = 44100;
let currentAudioURL = null;
let isRecording = false;
let targetDirectoryHandle = null;

const MP3_FILENAME = 'my_record.mp3';
const PREFERRED_DIRECTORY = 'C:\\dev\\SmartCloset';

const startButton  = document.getElementById('startButton');
const stopButton   = document.getElementById('stopButton');
const dirButton    = document.getElementById('dirButton');
const audioElement = document.getElementById('audioElement');
const statusText   = document.getElementById('statusText');
const downloadLink = document.getElementById('downloadLink');
const dirStatus    = document.getElementById('dirStatus');

startButton.addEventListener('click', startRecording);
stopButton.addEventListener('click', stopRecording);
dirButton.addEventListener('click', selectDirectoryForSaving);

// ----- 녹음 시작 -----
async function startRecording() {
  if (isRecording) return;

  try {
    audioContext = new (window.AudioContext || window.webkitAudioContext)();
    await audioContext.resume();

    micStream = await navigator.mediaDevices.getUserMedia({ audio: true });
    audioSampleRate = audioContext.sampleRate;
    audioChunks = [];

    sourceNode = audioContext.createMediaStreamSource(micStream);
    processorNode = audioContext.createScriptProcessor(4096, 1, 1);
    processorNode.onaudioprocess = (event) => {
      const inputData = event.inputBuffer.getChannelData(0);
      audioChunks.push(new Float32Array(inputData));
    };

    sourceNode.connect(processorNode);

    monitorNode = audioContext.createGain();
    monitorNode.gain.value = 0;
    processorNode.connect(monitorNode);
    monitorNode.connect(audioContext.destination);

    startButton.disabled = true;
    stopButton.disabled = false;
    downloadLink.classList.add('hidden');
    revokeAudioURL();
    updateStatus('녹음 중...');
    isRecording = true;
  } catch (error) {
    console.error('마이크 접근 에러:', error);
    updateStatus('마이크 권한을 확인해 주세요.');
    await cleanupAudioGraph();
    startButton.disabled = false;
    stopButton.disabled = true;
  }
}

// ----- 녹음 중지 + MP3 저장 -----
async function stopRecording() {
  if (!isRecording) return;

  const recordedChunks = audioChunks;
  audioChunks = [];
  await cleanupAudioGraph();
  isRecording = false;

  const bufferLength = recordedChunks.reduce((sum, chunk) => sum + chunk.length, 0);
  if (bufferLength === 0) {
    updateStatus('녹음된 데이터가 없습니다. 다시 시도해 주세요.');
    startButton.disabled = false;
    stopButton.disabled = true;
    return;
  }

  updateStatus('MP3 변환 중...');
  let mp3Blob;
  try {
    const mergedBuffer = mergeFloat32Arrays(recordedChunks, bufferLength);
    mp3Blob = encodeMp3(mergedBuffer, audioSampleRate);
  } catch (error) {
    console.error('MP3 인코딩 실패:', error);
    updateStatus('MP3 인코딩에 실패했습니다. 콘솔을 확인해 주세요.');
    startButton.disabled = false;
    stopButton.disabled = true;
    return;
  }

  currentAudioURL = URL.createObjectURL(mp3Blob);
  audioElement.src = currentAudioURL;
  audioElement.play().catch(() => {
    // 자동 재생 실패 시 사용자에게 버튼을 누르게 둔다.
  });

  downloadLink.href = currentAudioURL;
  downloadLink.classList.remove('hidden');
  downloadLink.download = MP3_FILENAME;
  downloadLink.textContent = `${MP3_FILENAME} 다시 저장`;

  startButton.disabled = false;
  stopButton.disabled = true;

  await saveMp3File(mp3Blob);
}

async function cleanupAudioGraph() {
  if (processorNode) {
    processorNode.disconnect();
    processorNode.onaudioprocess = null;
    processorNode = null;
  }

  if (monitorNode) {
    monitorNode.disconnect();
    monitorNode = null;
  }

  if (sourceNode) {
    sourceNode.disconnect();
    sourceNode = null;
  }

  if (micStream) {
    micStream.getTracks().forEach(track => track.stop());
    micStream = null;
  }

  if (audioContext) {
    try {
      await audioContext.close();
    } catch (err) {
      console.warn('AudioContext close error:', err);
    }
    audioContext = null;
  }
}

function mergeFloat32Arrays(chunks, totalLength) {
  const result = new Float32Array(totalLength);
  let offset = 0;

  for (const chunk of chunks) {
    result.set(chunk, offset);
    offset += chunk.length;
  }

  return result;
}

function encodeMp3(samples, sampleRate) {
  if (!window.lamejs) {
    throw new Error('lamejs 라이브러리가 로드되지 않았습니다.');
  }

  const Mp3Encoder = window.lamejs.Mp3Encoder;
  const mp3Encoder = new Mp3Encoder(1, sampleRate, 128);
  const sampleBlockSize = 1152;
  const mp3Data = [];

  for (let i = 0; i < samples.length; i += sampleBlockSize) {
    const sampleChunk = samples.subarray(i, i + sampleBlockSize);
    const int16Buffer = floatTo16BitPCM(sampleChunk);
    const encoded = mp3Encoder.encodeBuffer(int16Buffer);
    if (encoded.length > 0) {
      mp3Data.push(encoded);
    }
  }

  const end = mp3Encoder.flush();
  if (end.length > 0) {
    mp3Data.push(end);
  }

  return new Blob(mp3Data, { type: 'audio/mpeg' });
}

function floatTo16BitPCM(floatSamples) {
  const buffer = new Int16Array(floatSamples.length);
  for (let i = 0; i < floatSamples.length; i++) {
    const s = Math.max(-1, Math.min(1, floatSamples[i]));
    buffer[i] = s < 0 ? s * 0x8000 : s * 0x7FFF;
  }
  return buffer;
}

async function selectDirectoryForSaving() {
  if (!window.showDirectoryPicker) {
    updateDirStatus('브라우저가 디렉토리 선택을 지원하지 않습니다.', true);
    return;
  }

  try {
    const handle = await window.showDirectoryPicker();
    const hasPermission = await verifyDirPermission(handle);
    if (!hasPermission) {
      updateDirStatus('폴더 권한을 허용해야 저장할 수 있습니다.', true);
      return;
    }

    targetDirectoryHandle = handle;
    updateDirStatus(`선택된 폴더: ${handle.name} (C:\\dev\\SmartCloset를 선택하면 바로 저장됩니다.)`);
  } catch (error) {
    if (error.name === 'AbortError') {
      updateDirStatus('폴더 선택이 취소되었습니다.', true);
      return;
    }
    console.error('폴더 선택 실패:', error);
    updateDirStatus('폴더 선택 중 오류가 발생했습니다.', true);
  }
}

async function verifyDirPermission(handle) {
  const opts = { mode: 'readwrite' };
  if ((await handle.queryPermission?.(opts)) === 'granted') {
    return true;
  }
  if (handle.requestPermission) {
    return (await handle.requestPermission(opts)) === 'granted';
  }
  return false;
}

async function writeFileToDirectory(directoryHandle, blob) {
  const fileHandle = await directoryHandle.getFileHandle(MP3_FILENAME, { create: true });
  const writable = await fileHandle.createWritable();
  await writable.write(blob);
  await writable.close();
}

async function saveMp3File(blob) {
  if (targetDirectoryHandle) {
    try {
      const allowed = await verifyDirPermission(targetDirectoryHandle);
      if (allowed) {
        await writeFileToDirectory(targetDirectoryHandle, blob);
        updateStatus(`${MP3_FILENAME} 파일이 선택한 폴더(C:\\dev\\SmartCloset 권장)에 저장되었습니다.`);
        return;
      }
    } catch (error) {
      console.error('선택 폴더에 저장 실패:', error);
      updateStatus('선택한 폴더에 저장하지 못했습니다. 파일 선택 대화상자를 사용합니다.');
    }
  }

  if (typeof window.showSaveFilePicker === 'function') {
    try {
      const handle = await window.showSaveFilePicker({
        suggestedName: MP3_FILENAME,
        types: [
          {
            description: 'MP3 Audio',
            accept: { 'audio/mpeg': ['.mp3'] },
          },
        ],
      });
      const writable = await handle.createWritable();
      await writable.write(blob);
      await writable.close();
      updateStatus(`${MP3_FILENAME} 저장이 완료되었습니다.`);
      return;
    } catch (error) {
      if (error.name === 'AbortError') {
        updateStatus('파일 저장이 취소되었습니다. 링크로 직접 다운로드할 수 있습니다.');
        return;
      }
      console.error('파일 저장 실패:', error);
    }
  }

  triggerDownload(blob);
  updateStatus(`${MP3_FILENAME} 파일을 다운로드했습니다.`);
}

function triggerDownload(blob) {
  const tempURL = URL.createObjectURL(blob);
  const anchor = document.createElement('a');
  anchor.style.display = 'none';
  anchor.href = tempURL;
  anchor.download = MP3_FILENAME;
  document.body.appendChild(anchor);
  anchor.click();
  document.body.removeChild(anchor);
  setTimeout(() => URL.revokeObjectURL(tempURL), 2000);
}

function revokeAudioURL() {
  if (currentAudioURL) {
    URL.revokeObjectURL(currentAudioURL);
    currentAudioURL = null;
  }
}

function updateStatus(message) {
  statusText.textContent = message;
}

function updateDirStatus(message, isError = false) {
  dirStatus.textContent = `${message} (추천 경로: ${PREFERRED_DIRECTORY})`;
  dirStatus.style.color = isError ? '#c0392b' : '#555';
}

updateDirStatus('브라우저에서 C:\\dev\\SmartCloset 디렉토리를 선택하면 자동 저장됩니다.');

window.addEventListener('beforeunload', revokeAudioURL);
</script>
</body>
</html>
